"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var ReactDOM = require("react-dom");
var classHelpers_1 = require("../../../utilities/classHelpers");
var diacriticsStripper_1 = require("../../../utilities/diacriticsStripper");
var utils_1 = require("../../../utilities/utils");
var formCore_1 = require("../formCore");
var validationWrapper_1 = require("../validationWrapper");
var icon_1 = require("./../../display/icon");
var button_1 = require("./../../interaction/button");
var grid_1 = require("./../../layout/grid");
function isElement(node) {
    return node && !!node.querySelector;
}
var AutoCompleteLegacyInput = /** @class */ (function (_super) {
    tslib_1.__extends(AutoCompleteLegacyInput, _super);
    function AutoCompleteLegacyInput(props) {
        var _this = _super.call(this, props) || this;
        // drive this through css ideally. Currently fixed height plus border (50 + 2px)
        _this.itemHeight = 52;
        _this.state = {
            filteredOptions: [],
            query: "",
            open: false,
            selectedValue: props.multiSelect ? [] : null,
            selectedIndex: 0,
            remoteSearching: false,
            offsetIndex: 0,
            showOnTop: false,
            topOffset: -35,
        };
        _this.diacriticsStripper = new diacriticsStripper_1.DiacriticsStripper();
        return _this;
    }
    AutoCompleteLegacyInput.prototype.filterRemote = function (query, immediate) {
        var _this = this;
        if (this.timer) {
            window.clearTimeout(this.timer);
        }
        this.timer = window.setTimeout(function () {
            _this.setState({ remoteSearching: true });
            _this.props.remoteQuery(query).then(function (filteredOptions) {
                _this.setState({ filteredOptions: filteredOptions, remoteSearching: false });
            });
        }, immediate ? 0 : this.props.remoteThrottle);
    };
    AutoCompleteLegacyInput.prototype.filter = function (query) {
        var _this = this;
        var q = query.toLowerCase();
        if (this.props.remoteQuery) {
            if (query.length >= this.props.minimumLength) {
                this.filterRemote(query);
            }
        }
        else {
            if (query.length < this.props.minimumLength) {
                this.setState({ filteredOptions: this.props.options, query: query }, function () { return _this.constrainIndex(); });
            }
            else {
                this.setState({ filteredOptions: utils_1.utils.array.reject(this.props.options, function (o) { return _this.match(o.name, q); }), query: query }, function () { return _this.constrainIndex(); });
            }
        }
    };
    AutoCompleteLegacyInput.prototype.match = function (value1, value2) {
        value1 = value1.toLowerCase();
        value2 = value2.toLowerCase();
        if (this.props.ignoreDiacritics) {
            value1 = this.diacriticsStripper.removeDiacritics(value1);
        }
        return value1.toLowerCase().indexOf(value2) === -1;
        // if (this.props.stripDiacritics){
        // }
    };
    AutoCompleteLegacyInput.prototype.focusInput = function (e) {
        if (!e) {
            this.handleFocus();
        }
        else if (!this.state.open && !formCore_1.getEventTargetAs(e).classList.contains("clear-selected")) {
            this.handleFocus();
        }
    };
    AutoCompleteLegacyInput.prototype.handleFocus = function () {
        var _this = this;
        this.setState({ open: true, showOnTop: this.shouldShowOnTop() }, function () {
            var foundNode = ReactDOM.findDOMNode(_this);
            if (!isElement(foundNode)) {
                return;
            }
            var element = foundNode.querySelector("input");
            if (!element) {
                return;
            }
            element.focus();
            document.addEventListener("click", _this, false);
            if (_this.props.remoteQueryOnOpen) {
                _this.filterRemote("", true);
            }
        });
    };
    AutoCompleteLegacyInput.prototype.handleEvent = function (e) {
        // The second or check here is to allow for handling of deletion clicks on multi-select items after they have been removed from the dom
        if (ReactDOM.findDOMNode(this).contains(e.target) || e.target.classList.contains("multi-select-item-part")) {
            return;
        }
        this.setState({ open: false, query: "", filteredOptions: this.props.options || [] });
        document.removeEventListener("click", this, false);
    };
    AutoCompleteLegacyInput.prototype.componentWillUnmount = function () {
        document.removeEventListener("click", this, false);
    };
    AutoCompleteLegacyInput.prototype.componentWillMount = function () {
        var selectedValue = this.props.multiSelect ? [] : null;
        if (this.props.value) {
            if (this.props.multiSelect) {
                if (utils_1.utils.object.isArray(this.props.value)) {
                    selectedValue = this.props.value;
                }
                else {
                    selectedValue = [this.props.value];
                }
            }
            else {
                selectedValue = this.props.value;
            }
        }
        this.setState({ filteredOptions: this.props.options || [], selectedValue: selectedValue });
    };
    AutoCompleteLegacyInput.prototype.componentWillReceiveProps = function (newProps) {
        if (newProps.options !== this.props.options) {
            this.setState({ filteredOptions: newProps.options });
        }
        if (this.props.multiSelect) {
            var newMultiValue = newProps.value;
            var oldMultiValue = this.state.selectedValue;
            if (oldMultiValue.length === 0 || !utils_1.utils.object.isEqual(newMultiValue.map(function (v) { return v.id; }), oldMultiValue.map(function (v) { return v.id; }))) {
                this.setState({ selectedValue: newMultiValue || [] });
            }
        }
        else {
            var newSingleValue = newProps.value;
            var oldSingleValue = this.state.selectedValue;
            if (!newSingleValue) {
                if (oldSingleValue !== newSingleValue) {
                    this.setState({ selectedValue: null });
                }
            }
            else if (!oldSingleValue || newSingleValue.id !== oldSingleValue.id) {
                this.setState({ selectedValue: newSingleValue });
            }
        }
    };
    AutoCompleteLegacyInput.prototype.shouldShowOnTop = function () {
        var height = (this.itemHeight * 3) + 50;
        var foundNode = ReactDOM.findDOMNode(this);
        if (!isElement(foundNode)) {
            return;
        }
        var inputRect = foundNode.getBoundingClientRect();
        var remainingSpace = window.innerHeight - inputRect.bottom;
        var shouldShowOnTop = false;
        if (remainingSpace < height) {
            shouldShowOnTop = true;
        }
        else {
            shouldShowOnTop = false;
        }
        var offset = this.props.multiSelect ? -inputRect.height * 2 : -inputRect.height;
        var additionalOffset = 0;
        if (this.props.multiSelect && !shouldShowOnTop) {
            additionalOffset = inputRect.height;
        }
        this.setState({ topOffset: shouldShowOnTop ? offset : additionalOffset });
        return shouldShowOnTop;
    };
    AutoCompleteLegacyInput.prototype.checkKey = function (e) {
        var currentIndex = this.state.selectedIndex;
        if (e.keyCode === 27) {
            this.setState({ open: false, query: "", filteredOptions: this.props.options || [] });
        }
        if (e.keyCode === 40 && this.state.filteredOptions.length !== 0) {
            // DOWN ARROW
            var offsetIndex = Math.min((this.props.visibleItems || 3) - 1, this.state.offsetIndex + 1);
            var selectedIndex = Math.min(this.state.selectedIndex + 1, this.state.filteredOptions.length - 1);
            var foundNode = ReactDOM.findDOMNode(this);
            if (!isElement(foundNode)) {
                return;
            }
            var listElement = foundNode.querySelector(".autocomplete-select-list");
            this.setState({ offsetIndex: offsetIndex });
            if (offsetIndex >= 2) {
                listElement.scrollTop = (selectedIndex - 2) * this.itemHeight;
            }
            var selectedItem = this.state.filteredOptions[selectedIndex];
            this.setState({ selectedIndex: selectedIndex, query: selectedItem.name });
            e.preventDefault();
            return false;
        }
        if (e.keyCode === 38 && this.state.filteredOptions.length !== 0) {
            // UP ARROW
            var offsetIndex = Math.max(this.state.offsetIndex - 1, 0);
            var selectedIndex = Math.max(this.state.selectedIndex - 1, 0);
            var foundNode = ReactDOM.findDOMNode(this);
            if (!isElement(foundNode)) {
                return;
            }
            var listElement = foundNode.querySelector(".autocomplete-select-list");
            this.setState({ offsetIndex: offsetIndex });
            if (offsetIndex === 0) {
                listElement.scrollTop = (selectedIndex) * this.itemHeight;
            }
            var selectedItem = this.state.filteredOptions[selectedIndex];
            this.setState({ selectedIndex: selectedIndex, query: selectedItem.name });
            e.preventDefault();
            return false;
        }
        if (e.keyCode === 13 && this.state.filteredOptions.length !== 0) {
            // ENTER
            var selectedValue = this.state.filteredOptions[this.state.selectedIndex];
            this.handleSelection(selectedValue);
            e.preventDefault();
            return false;
        }
    };
    AutoCompleteLegacyInput.prototype.constrainIndex = function () {
        if (this.state.selectedIndex > this.state.filteredOptions.length - 1) {
            this.setState({ selectedIndex: Math.max(this.state.filteredOptions.length - 1, 0) });
        }
    };
    AutoCompleteLegacyInput.prototype.handleSelection = function (options) {
        if (this.props.multiSelect) {
            // Handle multiple selection
            var items = utils_1.utils.object.isArray(options) ? options : [options];
            var ddOptions_1 = this.state.selectedValue;
            utils_1.utils.array.each(items, function (option) {
                if (ddOptions_1.length !== 0 && utils_1.utils.array.some(ddOptions_1, function (ddo) { return ddo.id === option.id; })) {
                    // Remove
                    ddOptions_1 = utils_1.utils.array.reject(ddOptions_1, function (ddo) { return ddo.id === option.id; });
                }
                else {
                    // Add
                    ddOptions_1.push(option);
                }
            });
            this.setState({ selectedValue: ddOptions_1 });
            if (this.props.onSelected) {
                this.props.onSelected(ddOptions_1);
            }
            var foundNode = ReactDOM.findDOMNode(this);
            if (!isElement(foundNode)) {
                return;
            }
            var input = foundNode.querySelector("input");
            if (input) {
                input.focus();
            }
        }
        else {
            var option = options;
            // Handle single selection
            this.setState({ selectedValue: option, open: false, query: "", filteredOptions: this.props.options || [], offsetIndex: 0 });
            if (this.props.onSelected) {
                this.props.onSelected(option);
            }
            document.removeEventListener("click", this, false);
        }
    };
    AutoCompleteLegacyInput.prototype.buttonClick = function () {
        if (this.state.filteredOptions.length !== 0) {
            var selectedValue = this.state.filteredOptions[this.state.selectedIndex];
            if (selectedValue) {
                this.handleSelection(selectedValue);
            }
        }
    };
    AutoCompleteLegacyInput.prototype.checkToFilter = function (query) {
        var _this = this;
        this.setState({ query: query }, function () {
            if (_this.props.onChange) {
                _this.props.onChange(query);
            }
            if (_this.state.query !== _this.prevFilter) {
                _this.prevFilter = _this.state.query;
                _this.filter(_this.state.query);
            }
        });
    };
    AutoCompleteLegacyInput.prototype.render = function () {
        var _this = this;
        var validationMessage = formCore_1.DataValidationMessage.get(this.props);
        var validationMode = formCore_1.DataValidationMode.get(this.props);
        var classes = classHelpers_1.ClassHelpers.classNames("armstrong-input", "autocomplete-select", "" + (this.props.multiSelect && this.state.selectedValue.length !== 0 ? " has-multiple-options" : ""), this.props.className, {
            "has-go-button": this.props.hasGoButton,
            "disabled": this.props.disabled,
            "show-validation": (validationMode !== "none" && validationMessage),
        });
        return (React.createElement(grid_1.Grid, { title: validationMessage, onClick: function (e) { return _this.focusInput(e); }, className: classes },
            React.createElement(grid_1.Row, null,
                React.createElement(grid_1.Col, { className: "drop-down-controls" },
                    (!this.state.open || this.props.multiSelect) &&
                        React.createElement(grid_1.Grid, { className: "autocomplete-value-display" },
                            React.createElement(grid_1.Row, null,
                                React.createElement(grid_1.Col, null,
                                    this.state.selectedValue &&
                                        React.createElement("div", { className: "selected-value-wrapper" }, this.state.selectedValue && this.props.multiSelect ? this.state.selectedValue.map(function (ddo) {
                                            return React.createElement("div", { key: "multi-select-item-" + ddo.id, className: "multi-select-item multi-select-item-part" + (ddo.className ? " " + ddo.className : ""), onClick: function () { return _this.handleSelection(ddo); } },
                                                ddo.name,
                                                React.createElement(icon_1.Icon, { className: "multi-select-item-part", icon: icon_1.Icon.Icomoon.cross }));
                                        }) : this.state.selectedValue.name),
                                    (this.props.multiSelect && this.state.selectedValue.length === 0) &&
                                        React.createElement("div", { className: "placeholder" },
                                            "\u00A0",
                                            React.createElement("div", { className: "placeholder-value" }, !this.state.open && (this.props.placeholder || "start typing to filter results..."))),
                                    !this.props.multiSelect && this.state.selectedValue === null &&
                                        React.createElement("div", { className: "placeholder" },
                                            "\u00A0",
                                            React.createElement("div", { className: "placeholder-value" }, this.props.placeholder || "start typing to filter results..."))),
                                !this.props.multiSelect && this.state.selectedValue && this.props.canClear &&
                                    React.createElement(grid_1.Col, { width: "auto", className: "clear-selected p-right-xsmall", onClick: function () { return _this.setState({ selectedValue: _this.props.multiSelect ? [] : null, open: false, query: "", filteredOptions: _this.props.options || [] }); } },
                                        React.createElement(icon_1.Icon, { icon: icon_1.Icon.Icomoon.cross })),
                                this.props.multiSelect && this.state.selectedValue.length !== 0 && this.props.canClear &&
                                    React.createElement(grid_1.Col, { width: "auto", className: "clear-selected p-right-xsmall", onClick: function () { return _this.setState({ selectedValue: _this.props.multiSelect ? [] : null, open: false, query: "", filteredOptions: _this.props.options || [] }); } },
                                        React.createElement(icon_1.Icon, { icon: icon_1.Icon.Icomoon.cross })))),
                    this.state.open &&
                        React.createElement("div", { className: classHelpers_1.ClassHelpers.classNames("autocomplete-select-list-wrapper", this.props.multiSelect ? "multi-select" : "") },
                            React.createElement("input", tslib_1.__assign({ type: "text" }, formCore_1.DataValidationMessage.spread(validationMessage), { style: { marginTop: "" + (this.props.multiSelect && this.state.showOnTop && this.state.topOffset + "px") }, value: this.state.query, onKeyUp: function (e) { return _this.checkKey(e); }, onChange: function (e) { return _this.checkToFilter(formCore_1.getEventTargetAs(e).value); }, placeholder: this.props.placeholder || "start typing to filter results..." })),
                            this.state.remoteSearching && React.createElement(icon_1.Icon, { className: "spinner fg-info", icon: icon_1.Icon.Icomoon.spinner2 }),
                            React.createElement("div", { "data-id": "autocomplete-select-list", className: "autocomplete-select-list" + (this.state.showOnTop ? " on-top" : ""), style: { maxHeight: (this.props.visibleItems || 3) * this.itemHeight + "px", marginTop: this.state.topOffset + "px" } },
                                this.state.filteredOptions && this.state.filteredOptions.map(function (o, i) {
                                    return React.createElement("div", { "data-index": i, key: "dd-item-" + i, style: o.style, className: "dd-list-item" + (o.className ? " " + o.className : "") + (i === _this.state.selectedIndex ? " selected" : "") + ((_this.props.multiSelect && utils_1.utils.array.some(_this.state.selectedValue, function (ddo) { return ddo.id === o.id; })) ? " in-selected-list" : ""), onClick: function () { return _this.handleSelection(o); } },
                                        o.prefixElement,
                                        o.name);
                                }),
                                this.state.filteredOptions.length === 0 && this.state.query && React.createElement("div", { className: "dd-list-item-no-select" }, getNoResults(this.state.query, this.props.noResultsMessage))))),
                this.props.hasGoButton && !this.props.multiSelect && React.createElement(grid_1.Col, { width: "auto" },
                    React.createElement(button_1.Button, { className: "bg-positive", onClick: function () { return _this.buttonClick(); } }, this.props.goButtonContent || "Go"))),
            React.createElement(validationWrapper_1.ValidationLabel, { message: validationMessage, mode: validationMode, wrapper: function (p) { return React.createElement(grid_1.Row, { height: "auto" },
                    React.createElement(grid_1.Col, tslib_1.__assign({}, p))); } })));
    };
    AutoCompleteLegacyInput.defaultProps = {
        remoteThrottle: 500,
        minimumLength: 1,
    };
    return AutoCompleteLegacyInput;
}(React.Component));
exports.AutoCompleteLegacyInput = AutoCompleteLegacyInput;
function getNoResults(search, message) {
    if (!message) {
        return "No results...";
    }
    if (utils_1.utils.object.isFunction(message)) {
        return message(search);
    }
    return message;
}
