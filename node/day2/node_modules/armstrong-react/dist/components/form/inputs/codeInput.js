"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var index_1 = require("../../../index");
var keyCodes_1 = require("../../../utilities/keyCodes");
var utils_1 = require("../../../utilities/utils");
var formCore_1 = require("../formCore");
var formHooks_1 = require("../formHooks");
var validationWrapper_1 = require("../validationWrapper");
function calcTabIndex(tabIndex, fieldIndex) {
    if (tabIndex === undefined || tabIndex === -1) {
        return tabIndex;
    }
    return tabIndex + fieldIndex;
}
function getBindingName(index) {
    return "code_" + index;
}
var formData = {};
exports.CodeInput = function (props) {
    var _a = formHooks_1.useForm(formData), DataForm = _a.DataForm, bind = _a.bind, dataBinder = _a.dataBinder, notifyChange = _a.notifyChange;
    var onCodeChange = props.onCodeChange, lengthPerBox = props.lengthPerBox, numeric = props.numeric, type = props.type, className = props.className, tabIndex = props.tabIndex, value = props.value, placeholder = props.placeholder, readonly = props.readonly;
    var codeLength = React.useMemo(function () { return utils_1.utils.array.reduce(lengthPerBox, function (memo, num) { return memo + num; }, 0); }, [lengthPerBox]);
    var _b = React.useState(null), focusIndex = _b[0], setFocusIndex = _b[1];
    var _c = React.useState(""), code = _c[0], setCode = _c[1];
    var storedKey = React.useRef(null);
    var buildValue = React.useCallback(function () {
        var codeCandidate = "";
        utils_1.utils.array.each(lengthPerBox, function (lpb, idx) {
            var val = dataBinder.getValue(getBindingName(idx));
            codeCandidate += val ? val.toUpperCase() : "";
        });
        if (codeCandidate.length !== codeLength) {
            return;
        }
        if (codeCandidate === code) {
            return;
        }
        setCode(codeCandidate);
        if (numeric) {
            codeCandidate = parseInt(codeCandidate, 10);
        }
        if (onCodeChange) {
            onCodeChange(codeCandidate);
        }
    }, [lengthPerBox, onCodeChange, numeric, codeLength]);
    var onKeyUpFocusNext = React.useCallback(function (e) {
        var movingBack = false;
        var current = e.target;
        var el;
        var currentVal = current.value.trim();
        var lpb = lengthPerBox[focusIndex];
        var retFromStore = false;
        currentVal = currentVal.slice(0, lpb);
        if (e.keyCode === keyCodes_1.KeyCodes.backspace) {
            movingBack = true;
            if (currentVal.length === 0) {
                el = current.previousSibling;
            }
            else {
                el = current;
            }
        }
        else {
            el = current.nextSibling;
            if (storedKey.current && el && !el.value) {
                el.value = storedKey.current;
                storedKey.current = null;
                retFromStore = true;
            }
        }
        if (currentVal.length < lpb && !movingBack) {
            return;
        }
        if (el) {
            el.focus();
            if (el && el.value && !movingBack && !retFromStore) {
                el.select();
                // el.value = "";
            }
        }
        buildValue();
    }, [lengthPerBox, focusIndex, storedKey, buildValue]);
    var handlePaste = React.useCallback(function (e) {
        var pasted = e.clipboardData.getData("text/plain").replace(/\s/g, "");
        pasted = pasted.substr(0, codeLength).toUpperCase();
        if (numeric) {
            var parsed = parseInt(pasted, 10);
            if (isNaN(parsed)) {
                e.preventDefault();
                return false;
            }
        }
        var splitArray = [];
        var currentIndex = 0;
        utils_1.utils.array.each(lengthPerBox, function (lpb, idx) {
            var chunk = pasted.substr(currentIndex, lpb);
            currentIndex += lpb;
            splitArray.push(chunk);
            dataBinder.setValue(getBindingName(idx), chunk);
            // inputs.current[idx].value = chunk;
        });
        buildValue();
    }, [lengthPerBox, buildValue, numeric, codeLength]);
    var handleFocus = React.useCallback(function (index) { return function () {
        setFocusIndex(index);
        storedKey.current = null;
    }; }, [storedKey]);
    var keyDown = React.useCallback(function (e) {
        var lpb = lengthPerBox[focusIndex];
        var selectionLength = window.getSelection().toString().length;
        if (selectionLength === lpb) {
            return;
        }
        if (e.currentTarget.value.length === lpb) {
            if (e.keyCode >= keyCodes_1.KeyCodes.key_0 && e.keyCode <= keyCodes_1.KeyCodes.key_9) {
                storedKey.current = e.key;
            }
            if (e.keyCode >= keyCodes_1.KeyCodes.key_a && e.keyCode <= keyCodes_1.KeyCodes.key_z) {
                storedKey.current = e.key;
            }
        }
    }, [lengthPerBox, focusIndex, storedKey]);
    var handleClick = React.useCallback(function (e) {
        if (e.currentTarget.value) {
            e.currentTarget.select();
        }
    }, []);
    React.useEffect(function () {
        if (value) {
            var currentIndex_1 = 0;
            utils_1.utils.array.each(lengthPerBox, function (lpb, idx) {
                dataBinder.setValue(getBindingName(idx), value.substr(currentIndex_1, lpb));
                // inputs.current[i].value = ;
                currentIndex_1 += lpb;
            });
            notifyChange();
        }
    }, []);
    var validationMessage = formCore_1.DataValidationMessage.get(props);
    var validationMode = formCore_1.DataValidationMode.get(props);
    var classes = React.useMemo(function () { return index_1.ClassHelpers.classNames("armstrong-input", "code-input", className, {
        "show-validation": validationMode !== "none" && validationMessage,
    }); }, [className, validationMode, validationMessage]);
    return (React.createElement("div", { className: classes },
        React.createElement(DataForm, { onDataChanged: buildValue, className: classes }, lengthPerBox.map(function (lpb, i) { return (React.createElement("input", tslib_1.__assign({ className: "code-input-field", tabIndex: calcTabIndex(tabIndex, i), key: i, type: type || "text", placeholder: placeholder, maxLength: lpb, readOnly: readonly, onClick: handleClick, onFocus: handleFocus(i), onKeyUp: onKeyUpFocusNext, onKeyDown: keyDown, onPaste: handlePaste }, bind.text(getBindingName(i))))); })),
        React.createElement(validationWrapper_1.ValidationLabel, { message: validationMessage, mode: validationMode })));
};
exports.CodeInput.defaultProps = {
    lengthPerBox: [2, 2, 2],
};
